using System.Diagnostics;
using System.Numerics;
using System.Runtime.InteropServices;




namespace Swed32;

public partial class Swed
{
    public Process Proc { get; set; }

    public Swed(string procName)
    {
        Proc = SetProcess(procName);
    }

    public Swed(Process proc)
    {
        this.Proc = proc;
    }

    public Process GetProcess()
    {
        return Proc;
    }
        
    public Process SetProcess(string procName)
    {
        Proc = Process.GetProcessesByName(procName)[0];
            
        if (Proc == null)
            throw new InvalidOperationException("Process was not found, are you using the correct bit version and have no miss-spellings?");
            
        return Proc;
    }
        
    public IntPtr GetModuleBase(string moduleName) // generated by chatGPT
    {
        if (string.IsNullOrEmpty(moduleName))
        {
            throw new InvalidOperationException("moduleName was either null or empty.");
        }

        if (Proc == null)
        {
            throw new InvalidOperationException("process is invalid, check your init.");

        }

        try
        {
            if (moduleName.Contains(".exe"))
            {
                if (Proc.MainModule != null)
                    return Proc.MainModule.BaseAddress;
            }

            foreach (ProcessModule module in Proc.Modules)
            {
                if (module.ModuleName == moduleName)
                {
                    return module.BaseAddress;
                }
            }
        }
        catch (Exception)
        {
            throw new InvalidOperationException("Failed to find the specified module, search string might have miss-spellings.");
        }

        return IntPtr.Zero;
    }

    public IntPtr ReadPointer(IntPtr addy)
    {
        return ReadPointer(addy, 0);
    }

    public IntPtr ReadPointer(IntPtr addy, params int[] offsets)
    {
        var buffer = new byte[IntPtr.Size];
        
        foreach (var offset in offsets)
        {
            Kernel32.ReadProcessMemory(Proc.Handle, addy + offset, buffer, buffer.Length, IntPtr.Zero);
            addy = ReadPtrFromBuffer(buffer);
        }

        return addy;
    }

    private static IntPtr ReadPtrFromBuffer(ReadOnlySpan<byte> buffer)
    {
        const int szp32 = 4;
        const int szp64 = 8;
        Debug.Assert(buffer.Length is szp32 or szp64 && buffer.Length == IntPtr.Size);
        
        return buffer.Length switch
        {
            szp32 => (IntPtr)BitConverter.ToInt32(buffer),
            szp64 => (IntPtr)BitConverter.ToInt64(buffer),
            _ => throw new InvalidCastException(
                "Buffer wasn't 4 or 8 bytes wide")
        };
    }

    #region READ
        
    public byte[] ReadBytes(IntPtr addy, int bytes)
    {
        byte[] buffer = new byte[bytes];
        Kernel32.ReadProcessMemory(Proc.Handle, addy, buffer, buffer.Length, IntPtr.Zero);
        return buffer;
    }

    public byte[] ReadBytes(IntPtr addy, int offset, int bytes)
    {
        byte[] buffer = new byte[bytes];
        Kernel32.ReadProcessMemory(Proc.Handle, addy + offset, buffer, buffer.Length, IntPtr.Zero);
        return buffer;
    }

    public int ReadInt(IntPtr address)
    {
        return BitConverter.ToInt32(ReadBytes(address, 4));
    }

    public int ReadInt(IntPtr address, int offset)
    {
        return BitConverter.ToInt32(ReadBytes(address + offset, 4));
    }

    public float ReadFloat(IntPtr address)
    {
        return BitConverter.ToSingle(ReadBytes(address, 4));
    }

    public float ReadFloat(IntPtr address, int offset)
    {
        return BitConverter.ToSingle(ReadBytes(address + offset, 4));
    }

    public Vector3 ReadVec(IntPtr address)
    {
        var bytes = ReadBytes(address, 12);
        return new Vector3
        {
            X = BitConverter.ToSingle(bytes, 0),
            Y = BitConverter.ToSingle(bytes, 4),
            Z = BitConverter.ToSingle(bytes, 8)
        };
    }

    public Vector3 ReadVec(IntPtr address, int offset)
    {
        var bytes = ReadBytes(address + offset, 12);
        return new Vector3
        {
            X = BitConverter.ToSingle(bytes, 0),
            Y = BitConverter.ToSingle(bytes, 4),
            Z = BitConverter.ToSingle(bytes, 8)
        };
    }

    public short ReadShort(IntPtr address)
    {
        return BitConverter.ToInt16(ReadBytes(address, 2));
    }

    public short ReadShort(IntPtr address, int offset)
    {
        return BitConverter.ToInt16(ReadBytes(address + offset, 2));
    }

    public ushort ReadUShort(IntPtr address)
    {
        return BitConverter.ToUInt16(ReadBytes(address, 2));
    }

    public ushort ReadUShort(IntPtr address, int offset)
    {
        return BitConverter.ToUInt16(ReadBytes(address + offset, 2));
    }

    public uint ReadUInt(IntPtr address)
    {
        return BitConverter.ToUInt32(ReadBytes(address, 4));
    }

    public uint ReadUInt(IntPtr address, int offset)
    {
        return BitConverter.ToUInt32(ReadBytes(address + offset, 4));
    }

    public float[] ReadMatrix(IntPtr address, int length = 16)
    {
        var matrix = new float[length];
        var matrixByteSpan = MemoryMarshal.Cast<float, byte>(matrix);
        
        var readBytes = ReadBytes(address, matrixByteSpan.Length);
        readBytes.CopyTo(matrixByteSpan);

        return matrix;
    }

    #endregion

    #region WRITE
        
    public bool WriteBytes(IntPtr address, byte[] newbytes)
    {
        return Kernel32.WriteProcessMemory(Proc.Handle, address, newbytes, newbytes.Length, IntPtr.Zero);
    }

    public bool WriteBytes(IntPtr address, int offset, byte[] newbytes)
    {
        return Kernel32.WriteProcessMemory(Proc.Handle, address + offset, newbytes, newbytes.Length, IntPtr.Zero);
    }

    public bool WriteInt(IntPtr address, int value)
    {
        return WriteBytes(address, BitConverter.GetBytes(value));
    }

    public bool WriteInt(IntPtr address, int offset, int value)
    {
        return WriteBytes(address + offset, BitConverter.GetBytes(value));
    }

    public bool WriteShort(IntPtr address, short value)
    {
        return WriteBytes(address, BitConverter.GetBytes(value));
    }

    public bool WriteShort(IntPtr address, int offset, short value)
    {
        return WriteBytes(address + offset, BitConverter.GetBytes(value));
    }

    public bool WriteUShort(IntPtr address, ushort value)
    {
        return WriteBytes(address, BitConverter.GetBytes(value));
    }

    public bool WriteUShort(IntPtr address, int offset, ushort value)
    {
        return WriteBytes(address + offset, BitConverter.GetBytes(value));
    }

    public bool WriteUInt(IntPtr address, uint value)
    {
        return WriteBytes(address, BitConverter.GetBytes(value));
    }

    public bool WriteUInt(IntPtr address, int offset, uint value)
    {
        return WriteBytes(address + offset, BitConverter.GetBytes(value));
    }

    public bool WriteVec(IntPtr address, Vector3 value)
    {
        byte[] bytes = new byte[12];
        byte[] xBytes = BitConverter.GetBytes(value.X);
        byte[] yBytes = BitConverter.GetBytes(value.Y);
        byte[] zBytes = BitConverter.GetBytes(value.Z);
        xBytes.CopyTo(bytes, 0);
        yBytes.CopyTo(bytes, 4);
        zBytes.CopyTo(bytes, 8);
        return WriteBytes(address, bytes);
    }

    public bool WriteVec(IntPtr address, int offset, Vector3 value)
    {
        byte[] bytes = new byte[12];
        byte[] xBytes = BitConverter.GetBytes(value.X);
        byte[] yBytes = BitConverter.GetBytes(value.Y);
        byte[] zBytes = BitConverter.GetBytes(value.Z);
        xBytes.CopyTo(bytes, 0);
        yBytes.CopyTo(bytes, 4);
        zBytes.CopyTo(bytes, 8);
        return WriteBytes(address + offset, bytes);
    }

    public bool Nop(IntPtr address, int length)
    {
        byte[] nopArray = new byte[length];
        for (int i = 0; i < length; i++)
        {
            nopArray[i] = 0x90;
        }
        return WriteBytes(address, nopArray);
    }

    #endregion

    #region SIG SCANNING

    public IntPtr ScanForBytes32(string moduleName, string needle)
    {
        ProcessModule module = Proc.Modules.OfType<ProcessModule>().FirstOrDefault(x => x.ModuleName == moduleName);
            
        if (module == null)
            throw new InvalidOperationException("module was not found. Check your module name.");

        byte[] needleBytes = needle.Split(' ').Select(b => Convert.ToByte(b, 16)).ToArray();
        byte[] haystackBytes;

        if (module.FileName == null)
            throw new InvalidOperationException("module filename was null.");

        using (var stream = new FileStream(module.FileName, FileMode.Open, FileAccess.Read))
        {
            haystackBytes = new byte[stream.Length];
            stream.Read(haystackBytes, 0, (int)stream.Length);
        }
            
        return (IntPtr)ScanForBytes32(haystackBytes, needleBytes);
    }
        
    public int ScanForBytes32(byte[] haystack, byte[] needle)
    {
        for (int i = 0; i < haystack.Length - needle.Length; i++)
        {
            bool found = true;
            for (int j = 0; j < needle.Length; j++)
            {
                if (haystack[i + j] == needle[j]) 
                    continue;
                    
                found = false;
                break;
            }
                
            if (found)
                return i;
        }
            
        return -1;
    }
        
    #endregion
}